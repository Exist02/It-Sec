# Was ist Next.js

Next.js ist ein Webentwicklungs-Framework, das von Vercel entwickelt wurde, um die Erstellung von hochleistungsfähigen Webanwendungen zu vereinfachen. Next.js baut auf React auf und erweitert die Fähigkeiten von React um verschiedene Funktionen, wie statische Seitengenerierung (SSG) und serverseitiges Rendering (SSR). SSG generiert die Seiten bereits bei der Erstellung und ermöglicht so eine schnellere Auslieferung an die Nutzer; SSR rendert die Seiten bei der Anfrage und verkürzt so die Ladezeit. Kurz gesagt, Next.js bietet neue Funktionen zur Verbesserung der Leistung und der Benutzerfreundlichkeit.

# Technischer Hintergrund der CVE

CVE-2025-29927, eine kürzlich von Rachid und Yasser Allam entdeckte Sicherheitslücke in Next.js, hat gezeigt, dass es möglich ist, Autorisierungsprüfungen zu umgehen, wenn sie in der Middleware stattfinden. Middleware ist der Teil, der Entwicklern die Kontrolle über eingehende Anfragen gibt. Sie fungiert als Brücke zwischen der eingehenden Anfrage und dem Routing-System. Das Routing-System ist dateibasiert, d. h. Routen werden durch die Organisation von Dateien und Verzeichnissen erstellt und verwaltet. Diese Schwachstelle ermöglicht es Angreifern, die Middleware-basierte Autorisierung zu umgehen, und alle Versionen vor 14.2.25 und 15.2.3 sind für diese Schwachstelle anfällig.

Next.js ist in verschiedenen Anwendungstypen weit verbreitet, darunter E-Commerce-Plattformen, Nachrichten-Apps, Dokumentations-Sites und interaktive Web-Apps. Daher kann diese Sicherheitslücke schwerwiegende Folgen haben und erfordert von den Administratoren ein Upgrade ihrer Installationen auf eine gepatchte Version.

# Exploitation

## Curl
Die Exploitation ist via Curl u.A. möglich. Da die Schwachstelle lediglich wie in dem Initial Disclose (unterhalb via link) den HTTP "`x-middleware-subrequest: middleware`" Header braucht, damit die Anfrage seitens der Middleware nicht Modifiziert sondern direkt weitergereicht wird.

Initial Disclose:
https://zhero-web-sec.github.io/research-and-things/nextjs-and-the-corrupt-middleware

Beispiel via Curl:

```
curl -H "x-middleware-subrequest: middleware" http://10.10.31.241:3000/protected
```

## Burpsuite 

Was Curl kann kann Burpsuite natürlich erst recht. Hier fängt man erstmal ein Paket zum zugriff auf die Entsprechende seite (im Beispiel hier jetzt: http://10.10.31.241:3000/protected) ab. Bevor man das Paket aber wieder lossenden kann fügt man das argument "x-middleware-subrequest: middleware" zu dem HTTP Header hinzu. siehe Screenshot:
https://imgur.com/w88cyon

# Detection

## Manuell

Webserver-Protokolle können möglicherweise verwendet werden, um Beweise für diesen Angriff zu finden. Dies hängt jedoch davon ab, ob der Webserver so konfiguriert ist, dass er HTTP-Header aufzeichnet oder nicht. NodeJS ermöglicht beispielsweise die Protokollierung dieses spezifischen HTTP-Headers über request.headers[‚x-middleware-subrequest
Wenn die Webanwendung über einen Proxy läuft, muss die Protokollierungskonfiguration auf Webservern wie Nginx oder Apache2 geändert werden, um diesen speziellen Header zu protokollieren. Zum Beispiel kann das LogFormat in Apache2 verwendet werden:  

`LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{Benutzer-Agent}i\" \"%{x-middleware-subrequest}i\"" custom`

Sobald die Protokollierung dieses HTTP-Headers korrekt eingerichtet ist, können gängige Tools wie Grep, Yara usw. verwendet werden.

## Snort
Die folgende Snort-Regel kann, wenn sie als IDS verwendet wird, zur Erkennung von CVE-2025-29927 verwendet werden:

```
alert tcp any any -> any any (msg: "HTTP 'x-middleware-request' header detected, possible CVE-2025-29927 explotation"; content: "x-middleware-subrequest"; rawbytes; sid:10000001; rev:1)
```

Diese Regel untersucht das Paket ohne Berücksichtigung eines Protokolls, zum Beispiel des http_headers-Moduls. Dies liegt daran, dass der HTTP-Header "x-middleware-request" zum Zeitpunkt der Erstellung dieser Regel kein anerkannter Header in Snort ist.  

Zunächst fügen wir die Snort-Regel zu unseren lokalen Regeln hinzu. Unter Ubuntu befindet sich diese Regel standardmäßig unter /etc/snort/rules/local.rules. Nun fügen wir das obige Codeschnipsel ein und speichern es. Bitte beachten Sie, dass Sie den sid-Wert in einen anderen ändern müssen, wenn Sie bereits Regeln haben.

## Zeek
Zeek bietet eine umfassendere Möglichkeit zur Erkennung von Bedrohungen im Netzwerkverkehr. Für CVE-2025-29927 kann die folgende Zeek-Regel verwendet werden:

```
module CVE_2025_29927;

export {
    redef enum Log::ID += { LOG };
    global log_policy: Log::PolicyHook = Log::IGNORE;

    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "x-middleware-subrequest" && value == "middleware")
            Log::write(HTTP::LOG, [
                $timestamp=c$start_time,
                $uid=c$uid,
                $id=c$id,
                $note="CVE_2025_29927_Exploit",
                $msg="Detected HTTP header associated with CVE-2025-29927",
                $header=name,
                $value=value
           ]);
        notice_info(c, "CVE-2025-29927 Exploit", fmt("The HTTP header '%s' associated with CVE-2025-29927 was detected", value));
    }
  }
}
```
Stellen Sie sicher, dass diese Datei mit der Erweiterung .zeek im konfigurierten Verzeichnis für Zeek-Skripte gespeichert wird. Sie müssen Ihre local.zeek so ändern, dass sie dieses Skript enthält, indem Sie @load ./cve_2025_29927.zeek hinzufügen.